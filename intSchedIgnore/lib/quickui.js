// Generated by CoffeeScript 1.3.3

/*
Subclassing: low-level internals for creating new control classes using either
Control.sub() in JavaScript or CoffeeScript's built-in class syntax.

QuickUI control classes are subclasses of the base jQuery class. jQuery supports
the use of standard prototype-based classes such as are commonly found in
JavaScript projects. However, it turns out that jQuery's class scheme is quite
Byzantine. For conciseness, jQuery wants to support static constructors, that
is, creation of a new jQuery object without actually needing to use the "new"
keyword. So the following are equivalent:

  var $elements = $("div");
  var $elements = new $("div");

To achieve this, the base jQuery() constructor doesn't actually return a new
instance of the jQuery class. Rather, it returns a new instance of a helper
class called jQuery.prototype.init. The constructor does this regardless of
whether it's called with "new" or not, so it can produce the results above.

Any subclasses of jQuery need to support this helper class arrangement. To make
that easier, jQuery exposes an official plugin called $.sub() that returns a
subclass of jQuery. This creates a new subclass of jQuery *and* a new companion
helper class. The subclass' constructor actually returns a new instance of the
corresponding helper class.

That all works fine in JavaScript, but makes problems for CoffeeScript users.
CoffeeScript classes include a default constructor that is unaware of jQuery's
helper class shenanigans. QuickUI works around this problem in two ways:

1. The Control() constructor works exactly like one created by $.sub(), with the
   extra ability: whenever its invoked by a plain CoffeeScript subclass, it will
   automatically modify that class to conform to jQuery's helper class scheme.
   This allows you to create QuickUI subclasses with CoffeeScript's class
   syntax, and still end up with a jQuery-compatible class.
2. The Control.sub() function works just like jQuery's own $.sub() function,
   but the class' constructor is similarly modified to detect and modify plain
   CoffeeScript classes.

The result is that you can create a subclass of Control in JavaScript via
Control.sub(), or in CoffeeScript via the class syntax. Furthermore, you can
create subclasses of *those* classes in either language.
*/


/*
Return a class constructor that's capable of detecting whether it's been invoked
by a plain CoffeeScript class. If so, the class will be modified to be
compatible with jQuery.

The constructor needs to deal with two situations:
1. The class itself is being instantiated.
2. A CoffeeScript-based subclass of the class is being instantiated. The default
   constructor for a CoffeeScript class just invokes the base class'
   constructor. In that case, this constructor will ensure the subclass is
   compatible with jQuery and QuickUI before going further.

This is complicated by the fact the constructor may be invoked with "new", or in
a static form (without "new").

In all cases, the constructor ultimately returns an instance of an "init"
helper class, as is usual for jQuery subclasses created via $.sub().
*/


(function() {
  var classPropertyNameMap, coffeeClassNeedsCompatibility, controlClassData, controlConstructor, copyExcludingKeys, createElementReferenceFunction, createInitClass, createSubclass, cssClasses, elementInserted, elementInsertionInterval, evaluateControlJson, evaluateControlJsonProperties, evaluateControlJsonValue, findMethodImplementation, getCompoundPropertiesFromChildren, getPropertiesFromAttributes, inDocumentCallbacks, inDocumentListening, inDocumentListeningDeferred, initialize, isElementInDocument, isInputElement, makeCoffeeClassCompatible, mutationEvents, propertyNameMaps, rehydrateElement, render, replaceElements, restorePropertyCase, significantContent, startInDocumentListening, stopInDocumentListening, symbolCounter, updateSavedSize,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  controlConstructor = function() {
    return function(selector, context) {
      var classFn;
      if (this !== window) {
        classFn = this.constructor;
      } else {
        classFn = arguments.callee;
        while (classFn.caller.prototype instanceof classFn && classFn.caller.__super__ !== void 0) {
          classFn = classFn.caller;
        }
      }
      if (coffeeClassNeedsCompatibility(classFn)) {
        makeCoffeeClassCompatible(classFn);
      }
      return new classFn.prototype.init(selector, context);
    };
  };

  /*
  Return true if the given class has already been made jQuery + QuickUI compatible.
  */


  coffeeClassNeedsCompatibility = function(classFn) {
    if (classFn.hasOwnProperty("__super__")) {
      return classFn.__super__.constructor !== classFn.superclass;
    } else {
      return false;
    }
  };

  /*
  Create an "init" helper class per jQuery's class scheme. The init helper class
  is the one that actually does the real work in jQuery.
  */


  createInitClass = function(classFn) {
    var root;
    classFn.prototype.init = function(selector, context) {
      if (context && context instanceof jQuery && !(context instanceof classFn)) {
        context = classFn(context);
      }
      return jQuery.prototype.init.call(this, selector, context, root);
    };
    classFn.prototype.init.prototype = classFn.prototype;
    return root = classFn(document);
  };

  /*
  Return a jQuery-compatible subclass of the indicated superclass.
  */


  createSubclass = function(superclass) {
    var subclass;
    if (coffeeClassNeedsCompatibility(superclass)) {
      makeCoffeeClassCompatible(superclass);
    }
    subclass = controlConstructor();
    jQuery.extend(true, subclass, superclass);
    subclass.superclass = superclass;
    subclass.__super__ = superclass.prototype;
    subclass.prototype = superclass();
    subclass.prototype.constructor = subclass;
    subclass.fn = subclass.prototype;
    createInitClass(subclass);
    return subclass;
  };

  /*
  Make the indicated CoffeeScript class compatible with jQuery + QuickUI. This
  entails fixing up the class so that it looks identical to one created via
  Control.sub().
  
  One extra bit of work is extracting a class name from the class constructor
  generated by CoffeeScript. JavaScript developers using Control.sub() have to
  explicitly specify a class name, but CoffeeScript developers can simply use the
  language's class syntax, which will give the constructor a meaningful name.
  */


  makeCoffeeClassCompatible = function(classFn) {
    var superclass, _ref;
    superclass = classFn.__super__.constructor;
    classFn.superclass = superclass;
    if (coffeeClassNeedsCompatibility(superclass)) {
      makeCoffeeClassCompatible(superclass);
    }
    classFn.fn = classFn.prototype;
    createInitClass(classFn);
    return classFn.prototype.className = (_ref = classFn.name) != null ? _ref : /function\s+([^\( ]*)/.exec(classFn.toString())[1];
  };

  /*
  QuickUI
  Version 0.9.1
  Modular web control framework
  http://quickui.org
  
  Copyright 2009-2012 Jan Miksovsky
  Licensed under the MIT license.
  */


  /*
  QuickUI "control" jQuery extension to create and manipulate
  controls via a regular jQuery instance.
  
  Usage:
  
  $( element ).control()
    Returns the control that was created on that element.
  
  $( element ).control( { content: "Hello" } );
    Sets the content property of the control at this element.
  
  $( element ).control( MyControlClass );
    Creates a new instance of MyControlClass around the element( s ).
  
  $( element ).control( MyControlClass, { content: "Hello" } );
    Creates new control instance( s ) and sets its ( their ) content property.
  
  NOTE: the forms that create new control instances may return a jQuery array
  of elements other than the ones which were passed in. This occurs whenever
  the control class wants a different root tag than the tag on the supplied
  array of elements.
  */


  jQuery.fn.control = function(arg1, arg2) {
    var $cast, controlClass, properties;
    if (arg1 === void 0) {
      $cast = Control(this).cast(jQuery);
      if ($cast instanceof Control) {
        return $cast;
      } else {
        return null;
      }
    } else if (jQuery.isFunction(arg1)) {
      controlClass = arg1;
      properties = arg2;
      return controlClass.createAt(this, properties);
    } else {
      return Control(this).cast().properties(arg1);
    }
  };

  /*
  Control class: the base class for all QuickUI controls.
  
  This is defined as a subclass of jQuery so that all control objects can also
  have jQuery methods applied to them.
  */


  window.Control = createSubclass(jQuery);

  /*
  Class methods
  */


  Control.extend({
    /*
      Create an instance of this control class around a specific element (or
      multiple instances around a set of elements).
    */

    create: function(properties) {
      return this.createAt(null, properties);
    },
    /*
      Create instance(s) of this control class around the given target(s).
      
      If the tag associated with the given class differs from the tag on the
      target(s), a new element (or set of elements) will be created and used to
      replace the existing element(s). E.g., if one creates a button-based
      control on a div, the exiting div will get replaced with a button element.
      This will work for any existing element other than the document body,
      which will of course be left as a body element. Event handlers or CSS
      classes on the old element(s) will not be transferred to the new one(s).
      
      If properties are supplied, they will be set on the new controls.
      If the properties argument is a single string, it will be passed to
      the controls' content() property.
    */

    createAt: function(target, properties) {
      var $control, $controls, defaultTarget, element, existingTag, oldContents, _i, _len, _ref;
      defaultTarget = "<" + this.prototype.tag + "/>";
      $controls = void 0;
      oldContents = void 0;
      if (target === null) {
        $controls = this(defaultTarget);
        oldContents = [];
      } else {
        $controls = this(target);
        oldContents = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = $controls.length; _i < _len; _i++) {
            element = $controls[_i];
            _results.push(significantContent(element));
          }
          return _results;
        })();
        existingTag = $controls[0].nodeName.toLowerCase();
        if (existingTag !== this.prototype.tag.toLowerCase() && existingTag !== "body") {
          $controls = replaceElements($controls, this(defaultTarget));
        }
      }
      if (typeof properties === "string") {
        properties = {
          content: properties
        };
      }
      $controls.controlClass(this).addClass(cssClasses(this)).render().propertyVector("content", oldContents).properties(properties);
      _ref = $controls.segments();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        $control = _ref[_i];
        initialize(this, $control);
      }
      return $controls;
    },
    /*
      Create a subclass of this class. This overloads the standard jQuery $.sub()
      to permit a single argument: an object that is used to extent the prototype
      of the newly-created class.
    
      TODO: Update comments. Mention: Intended for use by JavaScript; CoffeeScript
      users can use "class".
    */

    sub: function(options) {
      var subclass;
      subclass = createSubclass(this);
      if (options != null) {
        subclass.prototype.extend(options);
      }
      return subclass;
    }
  });

  /*
  Control instance methods.
  */


  Control.prototype.extend({
    /*
      The CSS classes that should be applied to new instances of this class. This is
      normally not set directly, but a default value is automatically constructed
      the first time the control class is instantiated. The default value for this
      includes the names of all control classes in the class' inheritance
      hierarchy. Example: If a control class Foo has superclasses Bar and Control,
      this member will be "Foo Bar Control".
    */

    classes: "Control",
    /*
      Each control class knows its own name.
      We'd prefer to use "name" for this, but this is a reserved word.
    */

    className: "Control",
    /*
      Get/set the reference for the actual class for these control( s ). This may
      differ from the class of the jQuery object used to access this function:
        
        $e = Control "<button>"   # $e is now of type Control
        e.control( BasicButton )  # Turns the element into a BasicButton 
        $e.className              # Returns "Control"
        $e.controlClass()         # Returns the BasicButton class
    */

    controlClass: function(classFn) {
      if (classFn) {
        return this.data(controlClassData, classFn);
      } else {
        return this.data(controlClassData);
      }
    },
    /*
      Control itself has no settings that need to be applied on render.
    */

    inherited: null,
    /*
      Invoked when the control has finished rendering.
      Subclasses can override this to perform their own post-rendering work
      (e.g., wiring up events).
    */

    initialize: function() {},
    /*
      Rendering a control lets each class in the control class' hierarchy,
      starting at the *top*. Each class' "inherited" settings are passed to
      property setters on that class' superclass. That is, each class defines
      itself in the semantics of its superclass.
    */

    render: render = function() {
      var classFn, rendered, superclass;
      classFn = this.constructor;
      if (classFn !== Control) {
        superclass = classFn.superclass;
        rendered = superclass(this).render();
        if (classFn.prototype.hasOwnProperty("inherited")) {
          rendered.json(classFn.prototype.inherited, this);
        }
      }
      return this;
    },
    /*
      By default, the root tag of the control will be a div.
      Control classes can override this: <Control name="Foo" tag="span">
    */

    tag: "div",
    /*
      Replace this control with an instance of the given class and properties.
      Unlike a normal Control.create() call, existing control contents are
      *not* preserved. Event handlers, however, remain attached;
      use a separate call to $.off() to remove them if desired.
      
      If preserveClasses is true, the existing class hierarchy will be left
      on the "class" attribute, although the class "Control" will remain the
      rightmost class. Suppose the class hierarchy looks like
           class="Foo Control"
      If we're switching to class Bar, the hierarchy will end up like
           class="Bar Foo Control"
      
      TODO: This function have evolved to overlap quite a bit with $.control().
      The latter's ability to preserve element content in Control.createAt() 
      perhaps should be deprecated. Callers could rely on transmute() if they
      need to preserve existing content.
    */

    transmute: function(newClass, preserveContent, preserveClasses, preserveEvents) {
      var $controls, classFn, element, oldClasses, oldContents;
      classFn = Control.getClass(newClass);
      oldContents = preserveContent ? (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          element = this[_i];
          _results.push(significantContent(element));
        }
        return _results;
      }).call(this) : null;
      oldClasses = (preserveClasses ? this.prop("class") : null);
      this.empty().removeClass().removeData();
      if (!preserveEvents) {
        this.off();
      }
      $controls = classFn.createAt(this);
      if (oldContents) {
        $controls.propertyVector("content", oldContents);
      }
      if (oldClasses) {
        $controls.removeClass("Control").addClass(oldClasses).addClass("Control");
      }
      return $controls;
    },
    /*
      The current version of QuickUI.
    */

    quickui: "0.9.1"
  });

  /*
  Private helpers
  */


  controlClassData = "_controlClass";

  /*
  Return a class' "classes" member, which reflects the CSS classes that should be
  applied to new instances of that control class. If a class doesn't yet define
  this member for itself, a default value is calculated which includes the
  control class' own name, followed by the "classes" member of its superclass.
  */


  cssClasses = function(classFn) {
    if (!classFn.prototype.hasOwnProperty("classes")) {
      classFn.prototype.classes = classFn.prototype.className + " " + (cssClasses(classFn.superclass));
    }
    return classFn.prototype.classes;
  };

  /*
  Invoke the initialize() method of each class in the control's class hierarchy,
  starting with the base class and working down.
  */


  initialize = function(classFn, $control) {
    var superclass;
    superclass = classFn.superclass;
    if (superclass !== jQuery) {
      initialize(superclass, $control);
    }
    if (classFn.prototype.hasOwnProperty("initialize")) {
      return classFn.prototype.initialize.call($control);
    }
  };

  /*
  Replace the indicated existing element(s) with the indicated replacements and
  return the new elements. This is used if, say, we need to convert a bunch of
  divs to buttons. Significantly, this preserves element IDs.
  */


  replaceElements = function($existing, $replacement) {
    var $new, element, i, id, ids, _i, _len;
    ids = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = $existing.length; _i < _len; _i++) {
        element = $existing[_i];
        _results.push($(element).prop("id"));
      }
      return _results;
    })();
    $new = $replacement.replaceAll($existing);
    for (i = _i = 0, _len = $new.length; _i < _len; i = ++_i) {
      element = $new[i];
      id = ids[i];
      if (id && id.length > 0) {
        $(element).prop("id", id);
      }
    }
    return $new;
  };

  /*
  Return an element's "significant" contents: contents which contain
  at least one child that's something other than whitespace or comments.
  If the element has no significant contents, return undefined.
  */


  significantContent = function(element) {
    var content, node, _i, _len;
    content = Control(element).content();
    if (typeof content === "string" && jQuery.trim(content).length > 0) {
      return content;
    }
    for (_i = 0, _len = content.length; _i < _len; _i++) {
      node = content[_i];
      if (node.nodeType !== 8) {
        if (typeof node !== "string" || jQuery.trim(node).length > 0) {
          return content;
        }
      }
    }
    return void 0;
  };

  /*
  Standardized handling of element content.
  */


  Control.prototype.extend({
    /*
      Get/set the content of an HTML element.
      
      Like $.contents(), but you can also set content, not just get it.
      You can set content to a single item, an array of items, or a set
      of items listed as parameters. Setting multiple items at a time
      is an important case in compiled QuickUI markup. Input elements
      are also handled specially: their value ( val ) is their content.
      
      This function attempts to return contents in a canonical form, so
      that setting contents with common parameter types is likely to
      return those values back in the same form. If there is only one
      content element, that is returned directly, instead of returning
      an array of one element. If the element being returned is a text node,
      it is returned as a string.
      
      Usage:
       $element.content( "Hello" )              # Simple string
       $element.content( ["Hello", "world"] )   # Array
       $element.content( "Hello", "world" )     # Parameters
       Control( "<input type='text'/>" ).content( "Hi" )   # Sets text value
      
      This is used as the default implementation of a control's content
      property. Controls can override this behavior.
    */

    content: function(value) {
      var $element, array, item, result, _i, _len, _ref, _ref1;
      if (value === void 0) {
        $element = this.nth(0);
        if (isInputElement($element[0])) {
          return $element.val();
        } else {
          result = (function() {
            var _i, _len, _ref, _results;
            _ref = $element.contents();
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              _results.push(item.nodeType === 3 ? item.nodeValue : item);
            }
            return _results;
          })();
          if (result.length === 1 && typeof result[0] === "string") {
            return result[0];
          } else {
            return this.constructor(result);
          }
        }
      } else {
        array = arguments.length > 1 ? arguments : value instanceof jQuery ? value.get() : jQuery.isArray(value) ? value : [value];
        _ref = this.segments();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          $element = _ref[_i];
          if (isInputElement($element[0])) {
            $element.val(value);
          } else {
            $element.children().detach();
            (_ref1 = $element.empty()).append.apply(_ref1, array);
          }
        }
        return this;
      }
    }
  });

  /*
  Return true if the given element is an input element with a val().
  Exception: buttons are not considered input elements, because typically
  when one is setting their contents, one wants to set their label, not
  their "value".
  */


  isInputElement = function(element) {
    var inputTags;
    inputTags = ["input", "select", "textarea"];
    return (jQuery.inArray(element.nodeName.toLowerCase(), inputTags)) >= 0;
  };

  /*
  Let controls get notified when they are added to the document.
  */


  /*
  A (new) control is asking to have a callback invoked when the control
  has been inserted into the document body. This is useful because
  the initialize event is often invoked before the control has actually
  been added to the document, and therefore doesn't have height or width,
  doesn't have any externally-imposed styles applied to it, etc.
  
  If the control is already in the document, the callback is executed
  immediately.
  
  If no callback function is supplied, this returns true if all controls
  are in the document, and false if not.
  
  inDocumentCallbacks will be invoked in reserve document order to ensure that
  the callback of a child will be invoked before the callback of a parent.
  This lets the parent proceed knowing that its children have already had
  the chance to set themselves up.
  */


  Control.prototype.inDocument = function(callback) {
    var element, i, newCallbacks, _i, _j, _len, _len1;
    if (callback === void 0) {
      if (this.length === 0) {
        return false;
      }
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        element = this[_i];
        if (!isElementInDocument(element)) {
          return false;
        }
      }
      return true;
    } else {
      newCallbacks = [];
      for (i = _j = 0, _len1 = this.length; _j < _len1; i = ++_j) {
        element = this[i];
        if (isElementInDocument(element)) {
          callback.call(this.constructor(element));
        } else {
          newCallbacks.push({
            element: element,
            callback: callback
          });
        }
      }
      if (newCallbacks.length > 0) {
        inDocumentCallbacks.unshift.apply(inDocumentCallbacks, newCallbacks);
        if (!inDocumentListening) {
          startInDocumentListening();
        }
      }
      return this;
    }
  };

  /*
  An element has been added to the document; see if it's a control that's been
  waiting to be notified of that event via an inDocument() callback.
  */


  elementInserted = function(event) {
    var callback, callbacksReady, control, element, i, _i, _len, _results;
    callbacksReady = [];
    i = 0;
    while (i < inDocumentCallbacks.length) {
      element = inDocumentCallbacks[i].element;
      if (isElementInDocument(element)) {
        callbacksReady.push(inDocumentCallbacks[i]);
        inDocumentCallbacks.splice(i, 1);
      } else {
        i++;
      }
    }
    if (inDocumentCallbacks.length === 0) {
      stopInDocumentListening();
    }
    _results = [];
    for (_i = 0, _len = callbacksReady.length; _i < _len; _i++) {
      callback = callbacksReady[_i];
      control = Control(callback.element).control();
      _results.push(callback.callback.call(control));
    }
    return _results;
  };

  Control._elementInserted = elementInserted;

  elementInsertionInterval = null;

  inDocumentCallbacks = [];

  inDocumentListening = false;

  inDocumentListeningDeferred = false;

  /*
  Return true if the document body contains the indicated element, or if
  if the element *is* the document body.
  */


  isElementInDocument = function(element) {
    return (typeof document !== "undefined" && document !== null ? document.body : void 0) === element || jQuery.contains(document.body, element);
  };

  /*
  Return true if we can rely on DOM mutation events to detect DOM changes.
  */


  mutationEvents = function() {
    return !jQuery.browser.msie || parseInt(jQuery.browser.version) >= 9;
  };

  /*
  Start listening for insertions of elements into the document body.
  
  On modern browsers, we use the DOMNodeInserted mutation event (which, as of
  7/2011, had better browser coverage than DOMNodeinDocument).
  Mutation events are slow, but the only way to reliably detect insertions
  that are created outside the document and then later added in. The events
  aren't used when we can avoid it, and the event is unbound once all known
  pending controls have been added.
   
  IE8 doesn't support mutation events, so we have to set up our own polling
  interval to check to see whether a control has been added. Again, we avoid
  doing this at all costs, but this apparently is the only way we can
  determine when elements have been added in IE8.
  */


  startInDocumentListening = function() {
    if (mutationEvents()) {
      if (document.body) {
        jQuery("body").on("DOMNodeInserted", elementInserted);
        return inDocumentListening = true;
      } else if (!inDocumentListeningDeferred) {
        jQuery("body").ready(function() {
          elementInserted();
          if (inDocumentCallbacks.length > 0) {
            startInDocumentListening();
          }
          return inDocumentListeningDeferred = false;
        });
        return inDocumentListeningDeferred = true;
      }
    } else {
      return elementInsertionInterval = window.setInterval(function() {
        return elementInserted();
      }, 10);
    }
  };

  /*
  Stop listening for element insertion events.
  */


  stopInDocumentListening = function() {
    if (mutationEvents()) {
      jQuery("body").off("DOMNodeInserted", Control.elementInserted);
      return inDocumentListening = false;
    } else {
      window.clearInterval(elementInsertionInterval);
      return elementInsertionInterval = null;
    }
  };

  /*
  Control JSON: a JSON scheme for defining a control class.
  */


  /*
  Apply the indicated JSON to the control. Each key in the JSON will
  invoke the corresponding setter function in a function chain. E.g.,
  the JSON dictionary
  
       {
           foo: "Hello",
           bar: "World"
       }
  
  will invoke this.foo( "Hello" ).bar( "World" ).
  
  If a dictionary value is itself a JSON object, it will be reconstituted
  into HTML, or controls, or an array.
  
  This is similar to properties(), but that function doesn't attempt any
  processing of the values.
  
  The logicalParent parameter is intended for internal use only.
  */


  Control.prototype.json = function(json, logicalParent) {
    var control, i, properties, _i, _len, _ref;
    if (logicalParent == null) {
      logicalParent = this;
    }
    _ref = this.segments();
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      control = _ref[i];
      properties = evaluateControlJsonProperties(json, logicalParent.nth(i));
      control.properties(properties);
    }
    return this;
  };

  /*
  Return a copy of the given object, skipping the indicated keys.
  Keys should be provided as a dictionary with true values. E.g., the dictionary
  { a: true, b: true } specifies that keys "a" and "b" should be excluded
  from the result.
  */


  copyExcludingKeys = function(obj, excludeKeys) {
    var key, result;
    result = {};
    for (key in obj) {
      if (!excludeKeys[key]) {
        result[key] = obj[key];
      }
    }
    return result;
  };

  /*
  Create the control from the given JSON. This will be of three forms.
  The first form creates a control:
  
   {
     control: "MyButton",
     ref: "foo",     
     content: "Hello, world."
   }
  
  The special "control" property determines the class of the control. 
  The second form creates a plain HTML element:
  
   {
     html: "<div/>",
     ref: "foo"
   }
  
  The html can be any HTML string supported by jQuery. It can also be an HTML
  tag singleton without braces: e.g., "div" instead of needing "<div>" or
  "<div/>". In normal jQuery, a tag like "div" would be a selector, and would
  not create an element. But in the context of creating controls, it seems
  more useful to interpret this to create an element of the indicated type.
  
  The "ref" property is special, in that it is handled by the logical parent
  of the element being defined rather than by the element itself. The logical
  parent is the control whose definition included the JSON being processed here.
  
  The third form is any other JSON dictionary object, returned as is.
  */


  evaluateControlJson = function(json, logicalParent) {
    var control, firstKey, html, properties, reservedKeys, stripped;
    for (firstKey in json) {
      break;
    }
    if (firstKey !== "html" && firstKey !== "control") {
      return json;
    }
    reservedKeys = {
      ref: true
    };
    reservedKeys[firstKey] = true;
    stripped = copyExcludingKeys(json, reservedKeys);
    properties = evaluateControlJsonProperties(stripped, logicalParent);
    control = void 0;
    if (firstKey === "html") {
      html = json.html;
      if (/^\w+$/.test(html)) {
        html = "<" + html + ">";
      }
      control = Control(html).properties(properties);
    } else {
      control = Control.getClass(json.control).create(properties);
    }
    if (json.ref) {
      logicalParent.referencedElement(json.ref, control);
    }
    return control;
  };

  /*
  For each key in the given JSON object, evaluate its value.
  
  If the JSON is a scalar value (e.g., a string) or array, this will implicitly
  be taken as a content property. E.g., a json argument of "Hello" would have
  the same as { content: "Hello" }.
  */


  evaluateControlJsonProperties = function(json, logicalParent) {
    var key, properties;
    if (!jQuery.isPlainObject(json)) {
      json = {
        content: json
      };
    }
    properties = {};
    for (key in json) {
      properties[key] = evaluateControlJsonValue(json[key], logicalParent);
    }
    return properties;
  };

  /*
  Determine the value of the given JSON object found during the processing
  of control JSON.
  
  If the supplied json is a JavaScript object, it will be treated as a control
  and created from that object's properties.
  If it's an array, its items will be mapped to their values using this same
  function.
  Otherwise, the object is returned as is.
  
  The "logical parent" is the control whose JSON defined the elements being
  created. The logical parent for a given element may not be the element's
  immediate parent in the DOM; it might be higher up.
  */


  evaluateControlJsonValue = function(value, logicalParent) {
    var item, itemValue, _i, _len, _results;
    if (jQuery.isArray(value)) {
      _results = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        item = value[_i];
        _results.push((itemValue = evaluateControlJsonValue(item, logicalParent), itemValue instanceof jQuery ? itemValue[0] : itemValue));
      }
      return _results;
    } else if (jQuery.isPlainObject(value)) {
      return evaluateControlJson(value, logicalParent);
    } else {
      return value;
    }
  };

  /*
  Layout helpers.
  */


  /*
  See if the control's size has changed since the last time we checked and,
  if so, trigger the sizeChanged event.
  
  A control can use this method to let layout-performing ancestors know
  that the control has changed its size, in case the ancestor will now
  need to update the layout.
  */


  Control.prototype.checkForSizeChange = function() {
    if (updateSavedSize(this)) {
      this.trigger("sizeChanged");
    }
    return this;
  };

  /*
  Layout event.
  
  Elements can use the layout event if they want to perform custom layout when
  their size changes. The layout contract is weak: it's generally triggered
  when the window size changes AND the element's size has actually changed in
  response.
   
  The layout event will *notautomatically fire if the element's size has
  changed in response to other activity, such as a child element growing in
  size. Supporting that generally would require setting up an expensive poll
  interval. However, a contained element that want to let their containers
  know about changes in the contained element's size can do so by triggering
  a layout event that will bubble up to the container.
  */


  jQuery.event.special.layout = {
    /*
      Add a layout event handler.
    */

    add: function(handleObj) {
      var layout;
      layout = jQuery.event.special.layout;
      layout._trackedElements = layout._trackedElements.add(this);
      return Control(this).inDocument(function() {
        /*
              Directly invoke the handler instead of triggering the event.
              If add() is invoked on an element that's already in the document,
              inDocument() will fire immediately, which means the handler won't
              be wired up yet.
        */

        var event, handler;
        handler = handleObj.handler;
        event = new jQuery.Event("layout");
        return handler.call(this, event);
      });
    },
    /*
      Handle the layout event.
    */

    handle: function(event) {
      var control;
      control = Control(this);
      if (!control.inDocument()) {
        return;
      }
      if (!control.checkForSizeChange()) {
        return;
      }
      return event.handleObj.handler.apply(this, arguments);
    },
    /*
      Called the first time the layout event is added to an element.
    */

    setup: function() {
      var layout;
      layout = jQuery.event.special.layout;
      if (!layout._trackingResizeEvent) {
        $(window).resize(function() {
          return layout._windowResized();
        });
        return layout._trackingResizeEvent = true;
      }
    },
    /*
      The last layout event handler for an element has been removed.
    */

    teardown: function() {
      return jQuery.event.special.layout._trackedElements = jQuery.event.special.layout._trackedElements.not(this);
    },
    /*
      The set of elements receiving layout events.
    */

    _trackedElements: $(),
    /*
      The window has been resized.
    */

    _windowResized: function() {
      return jQuery.event.special.layout._trackedElements.trigger("layout");
    }
  };

  /*
  Compare the control's current size with its previously recorded size.
  If the size has not changed, return false. If the size has changed,
  update the recorded size and return true.
  */


  updateSavedSize = function(control) {
    var previousSize, size, _ref;
    previousSize = (_ref = control.data("_size")) != null ? _ref : {};
    size = {
      height: control.height(),
      width: control.width()
    };
    if (size.height === previousSize.height && size.width === previousSize.width) {
      return false;
    } else {
      control.data("_size", size);
      return true;
    }
  };

  /*
  Localization
  */


  /*
  The control's culture.
  If jQuery Globalize is present, this defaults to the current culture.
  This can be overridden on a per-control basis, e.g., for testing purposes.
  
  Control classes can override this method to respond immediately to an
  explicit change in culture. They should invoke their base class' culture
  method, do whatever work they want ( if the culture parameter is defined ),
  then return the result of the base class call.
  */


  Control.prototype.culture = function(culture) {
    var controlCulture, cultureDataMember;
    cultureDataMember = "_culture";
    controlCulture = void 0;
    if (culture === void 0) {
      controlCulture = this.data(cultureDataMember);
      return controlCulture != null ? controlCulture : (window.Globalize ? Globalize.culture() : null);
    } else {
      controlCulture = (typeof culture === "string" ? Globalize.findClosestCulture(culture) : culture);
      return this.data(cultureDataMember, controlCulture);
    }
  };

  /*
  Helpers to efficiently define control class properties.
  QuickUI properties are jQuery-style getter/setter functions.
  */


  jQuery.extend(Control, {
    /*
      Given an array of functions, repeatedly invoke them as a chain.
      
      This function allows the compact definition of getter/setter functions
      for Control classes that are delegated to aspects of the control or
      elements within its DOM.
      
      For example:
      
          MyControl.prototype.foo = Control.chain( "$foo", "content" );
      
      will create a function foo() on all MyControl instances that sets or gets
      the content of the elements returned by the element function $foo(),
      which in turn likely means any element with id "#foo" inside the control.
      
      The parameters to chain are the names of functions that are invoked in
      turn to produce the result. The last parameter may be an optional side
      effect function that will be invoked whenever the chain function is
      invoked as a setter.
      
      The function names passed as parameters may also define an optional
      string-valued parameter that will be passed in. So chain( "css/display" )
      creates a curried setter/getter function equivalent to css( "display", value ).
    */

    chain: function() {
      var arg, args, functionNames, functionParams, i, parts, sideEffectFn, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (jQuery.isFunction(args[args.length - 1])) {
        sideEffectFn = args.pop();
      }
      functionNames = [];
      functionParams = [];
      for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
        arg = args[i];
        parts = arg.split("/");
        functionNames[i] = parts.shift();
        functionParams[i] = parts;
      }
      return function(value) {
        var fn, functionName, length, params, result, _j, _len1;
        result = this;
        length = functionNames.length;
        for (i = _j = 0, _len1 = functionNames.length; _j < _len1; i = ++_j) {
          functionName = functionNames[i];
          fn = result[functionName];
          if (fn === void 0) {
            throw "Control class " + this.className + " tried to chain to an undefined getter/setter function " + functionNames[i] + ".";
          }
          params = functionParams[i];
          if (i === length - 1 && value !== void 0) {
            params = params.concat([value]);
          }
          result = fn.apply(result, params);
        }
        if (value === void 0) {
          return result;
        } else {
          if (sideEffectFn) {
            sideEffectFn.call(this, value);
          }
          return this;
        }
      };
    },
    /*
      Return a function that applies another function to each control in a
      jQuery array.
      
      If the inner function returns a defined value other than "this", the function
      is assumed to be a property getter, and that result is returned immediately.
      Otherwise, "this" is returned to permit chaining.
    */

    iterator: function(fn) {
      return function() {
        var control, result, _i, _len, _ref;
        _ref = this.segments();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          control = _ref[_i];
          result = fn.apply(control, arguments);
          if (result !== void 0 && result !== control) {
            return result;
          }
        }
        return this;
      };
    },
    /*
      Generic factory for a property getter/setter.
    */

    property: function(sideEffectFn, defaultValue, converterFunction) {
      var backingPropertyName;
      backingPropertyName = "_property" + symbolCounter++;
      return function(value) {
        var control, result, _i, _len, _ref;
        result = void 0;
        if (value === void 0) {
          result = this.data(backingPropertyName);
          if (result === void 0) {
            return defaultValue;
          } else {
            return result;
          }
        } else {
          _ref = this.segments();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            control = _ref[_i];
            result = (converterFunction ? converterFunction.call(control, value) : value);
            control.data(backingPropertyName, result);
            if (sideEffectFn) {
              sideEffectFn.call(control, result);
            }
          }
          return this;
        }
      };
    }
  });

  /*
  Factories for getter/setters of various types.
  */


  jQuery.extend(Control.property, {
    bool: function(sideEffectFn, defaultValue) {
      return Control.property(sideEffectFn, defaultValue, function(value) {
        return String(value) === "true";
      });
    },
    /*
      A class-valued property.
      This accepts either a function (the class) or a class name as a string.
    */

    "class": function(sideEffectFn, defaultValue) {
      return Control.property(sideEffectFn, defaultValue, Control.getClass);
    },
    date: function(sideEffectFn, defaultValue) {
      return Control.property(sideEffectFn, defaultValue, function(value) {
        if (value instanceof Date || !(value != null)) {
          return value;
        } else {
          return new Date(Date.parse(value));
        }
      });
    },
    integer: function(sideEffectFn, defaultValue) {
      return Control.property(sideEffectFn, defaultValue, parseInt);
    }
  });

  symbolCounter = 0;

  /*
  Rehydration
  
  This takes static HTML created in normal means for SEO purposes, and looks for
  elements decorated with data- properties indicating which elements should be
  reconstituted as live QuickUI controls.
  */


  /*
  Rehydrate controls from static HTML.
  */


  Control.prototype.rehydrate = function() {
    var $e, controls, i, subcontrols, _i, _ref;
    subcontrols = this.find("[data-control]").get();
    if (subcontrols.length > 0) {
      for (i = _i = _ref = subcontrols.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        rehydrateElement(subcontrols[i]);
      }
    }
    controls = (function() {
      var _j, _len, _ref1, _results;
      _ref1 = this.segments();
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        $e = _ref1[_j];
        _results.push($e.data("control") ? rehydrateElement($e[0]) : $e);
      }
      return _results;
    }).call(this);
    return Control(controls).cast();
  };

  /*
  Rehydrate the given element as a control.
  */


  rehydrateElement = function(element) {
    var $element, className, controlClass, lowerCaseProperties, properties;
    $element = $(element);
    className = $element.data("control");
    $element.removeAttr("data-control");
    controlClass = Control.getClass(className);
    lowerCaseProperties = jQuery.extend({}, getPropertiesFromAttributes(element), getCompoundPropertiesFromChildren(element));
    properties = restorePropertyCase(controlClass, lowerCaseProperties);
    return jQuery(element).control(controlClass, properties);
  };

  /*
  Return the properties indicated on the given element's attributes.
  */


  getPropertiesFromAttributes = function(element) {
    var $element, attribute, key, match, properties, propertyName, regexDataProperty, _i, _len, _ref;
    properties = {};
    regexDataProperty = /^data-(.+)/;
    _ref = element.attributes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attribute = _ref[_i];
      match = regexDataProperty.exec(attribute.name);
      if (match) {
        propertyName = match[1];
        if (propertyName !== "control") {
          properties[propertyName] = attribute.value;
        }
      }
    }
    $element = jQuery(element);
    for (key in properties) {
      $element.removeAttr("data-" + key);
    }
    return properties;
  };

  /*  
  Return any compound properties found in the given element's children.
  */


  getCompoundPropertiesFromChildren = function(element) {
    var $compound, $compoundElements, $value, properties, propertyName, _i, _len, _ref;
    properties = {};
    $compoundElements = Control(element).children().filter("[data-property]");
    _ref = $compoundElements.segments();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      $compound = _ref[_i];
      propertyName = $compound.attr("data-property");
      if (propertyName !== "control") {
        $value = $compound.content();
        properties[propertyName] = $value;
        if ($value instanceof jQuery) {
          $value.detach();
        }
      }
    }
    $compoundElements.remove();
    return properties;
  };

  /*
  Map the given property dictionary, in which all property names may be in
  lowercase, to the equivalent mixed case names. Properties which are not
  found in the control class are dropped.
  */


  restorePropertyCase = function(controlClass, properties) {
    var map, mixedCaseName, propertyName, result;
    if (jQuery.isEmptyObject(properties)) {
      return properties;
    }
    map = classPropertyNameMap(controlClass);
    result = {};
    for (propertyName in properties) {
      mixedCaseName = map[propertyName.toLowerCase()];
      if (mixedCaseName) {
        result[mixedCaseName] = properties[propertyName];
      }
    }
    return result;
  };

  /*
  Cached maps for property names in rehydrated control classes. See below.
  */


  propertyNameMaps = {};

  /*
  Return a dictionary for the given class which maps the lowercase forms of
  its properties' names to their full mixed-case property names.
  */


  classPropertyNameMap = function(controlClass) {
    var className, lowerCaseName, map, mixedCaseName;
    className = controlClass.prototype.className;
    if (!propertyNameMaps[className]) {
      map = {};
      for (mixedCaseName in controlClass.prototype) {
        lowerCaseName = mixedCaseName.toLowerCase();
        map[lowerCaseName] = mixedCaseName;
      }
      propertyNameMaps[className] = map;
    }
    return propertyNameMaps[className];
  };

  /*
  Auto-loader for rehydration.
  Set data-create-controls="true" on the body tag to have the current
  page automatically rehydrated on load.
  */


  jQuery(function() {
    var $body;
    $body = Control("body");
    if ($body.data("create-controls")) {
      return $body.rehydrate();
    }
  });

  /*
  Helper functions for working with control styles.
  */


  Control.prototype.extend({
    /*
      Get/set whether the indicated class(es) are applied to the elements.
      This effectively combines $.hasClass() and $.toggleClass() into a single
      getter/setter.
    */

    applyClass: function(classes, value) {
      if (value === void 0) {
        return this.hasClass(classes);
      } else {
        return this.toggleClass(classes, String(value) === "true");
      }
    },
    /*
      The set of classes on the control's element.
      If no value is supplied, this gets the current list of classes.
      If a value is supplied, the specified class name(s) are *added*
      to the element. This is useful for allowing a class to be added
      at design-time to an instance, e.g., <Foo class="bar"/>. The
      resulting element will end up with "bar" as a class, as well as
      the control's class hierarchy: <div class="Foo Control bar">.
    */

    "class": function(classList) {
      if (classList === void 0) {
        return this.attr("class");
      } else {
        return this.toggleClass(classList, true);
      }
    },
    /*
      True if the control wants its generic appearance. The default value of this
      property is the control class' genericDefault member.
    */

    generic: function(generic) {
      return this.applyClass("generic", generic);
    },
    /*
      Sets/gets the style of matching elements.
      This lets one specify a style attribute in QuickUI markup for a control instance;
      the style will apply to the control's root element.
    */

    style: function(style) {
      return this.attr("style", style);
    },
    /*
      Toggle the element's visibility.
      Like $.toggle(), but if no value is supplied, the current visibility is returned
      (rather than toggling the element's visibility).
    */

    visibility: function(value) {
      if (value === void 0) {
        return this.is(":visible");
      } else {
        return this.toggle(String(value) === "true");
      }
    }
  });

  /*
  Helper function by which a method can invoke the identically-named method
  on a base class. Signficantly, it is not necessary for the invoking method to
  pass in the current class, the base class, or the method name.
  
  This function exists for use in plain JavaScript controls. CoffeeScript-based
  controls have access to that langauge's "super" keyword.
  */


  /*
  Call a function of the same name in a superclass.
  
  E.g., if A is a superclass of B, then:
  
       A.prototype.calc = function ( x ) {
           return x 2;
       }
       B.prototype.calc = function ( x ) {
           return this._super( x ) + 1;
       }
  
       var b = new B();
       b.calc( 3 );         # = 7
    
  This assumes a standard prototype-based class system in which all classes have
  a member called "superclass" pointing to their parent class, and all instances
  have a member called "constructor" pointing to the class which created them.
  
  This routine has to do some work to figure out which class defined the
  calling function. It will have to walk up the class hierarchy and,
  if we're running in IE, do a bunch of groveling through function
  definitions. To speed things up, the first call to _super() within a
  function creates a property called "_superFn" on the calling function;
  subsequent calls to _super() will use the memoized answer.
  
  Some prototype-based class systems provide a _super() function through the
  use of closures. The closure approach generally creates overhead whether or
  not _super() will ever be called. The approach below adds no overhead if
  _super() is never invoked, and adds minimal overhead if it is invoked.
  This code relies upon the JavaScript .caller method, which many claims
  has slow performance because it cannot be optimized. However, "slow" is
  a relative term, and this approach might easily have acceptable performance
  for many applications.
  */


  Control.prototype._super = function() {
    /*
      TODO: As of 1.3.1, CoffeeScript doesn't permit the creation of named
      functions. So the standard approach below doesn't work, and we have to resort
      to using the deprecated arguments.callee. Need to work around this.
      
      if _super and _super.caller
        _super.caller # Modern browser
      else
        arguments.callee.caller # IE9 and earlier
    */

    var callerFn, callerFnName, classFn, classInfo, superFn;
    callerFn = arguments.callee.caller;
    if (!callerFn) {
      throw "Tried to invoke _super(), but couldn't find the calling function.";
    }
    superFn = callerFn._superFn;
    if (!superFn) {
      classInfo = findMethodImplementation(callerFn, this.constructor);
      if (classInfo) {
        classFn = classInfo.classFn, callerFnName = classInfo.fnName;
        superFn = classFn.superclass.prototype[callerFnName];
        callerFn._superFn = superFn;
      }
      if (!superFn) {
        throw "Tried to invoke _super(), but couldn't find a function of the same name in the base class.";
      }
    }
    return superFn.apply(this, arguments);
  };

  /*
  Find which class implements the given method, starting at the given point in the
  class hierarchy and walking up. Returns the class that implements the function,
  and the name of the class member that references it. Returns null if the
  function's implementation could not be found.
  */


  findMethodImplementation = function(methodFn, classFn) {
    var key, value, _ref;
    _ref = classFn.prototype;
    for (key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      value = _ref[key];
      if (value === methodFn) {
        return {
          classFn: classFn,
          fnName: key
        };
      }
    }
    if (classFn.superclass) {
      return findMethodImplementation(methodFn, classFn.superclass);
    } else {
      return null;
    }
  };

  /*
  Utilities
  */


  jQuery.extend(Control, {
    /*
      Given a value, returns a corresponding class:
      - A string value returns the global class with that string name.
      - A function value returns that function as is.
      - An object value returns a new anonymous class created from that JSON.
    */

    getClass: function(value) {
      var classFn;
      if (value === null || value === "") {
        return null;
      } else if (jQuery.isFunction(value)) {
        return value;
      } else if (jQuery.isPlainObject(value)) {
        return Control.sub(value);
      } else {
        classFn = window[value];
        if (!classFn) {
          throw "Unable to find a class called " + value + ".";
        }
        return classFn;
      }
    },
    isControl: function(element) {
      return Control(element).control() !== void 0;
    }
  });

  /*
  Selector for ":control": reduces the set of matched elements to the ones
  which are controls.
   
  With this, $foo.is( ":control" ) returns true if at least one element in $foo
  is a control, and $foo.filter( ":control" ) returns just the controls in $foo.
  */


  jQuery.expr[":"].control = function(elem) {
    var controlClass;
    controlClass = Control(elem).controlClass();
    if (controlClass) {
      return controlClass === Control || controlClass.prototype["instanceof"](Control);
    } else {
      return false;
    }
  };

  Control.prototype.extend({
    /*
      Return the array of elements cast to their closest JavaScript class ancestor.
      E.g., a jQuery $( ".foo" ) selector might pick up instances of control classes
      A, B, and C. If B and C are subclasses of A, this will return an instance of
      class A. So Control( ".foo" ).cast() does the same thing as A( ".foo" ), but without
      having to know the type of the elements in advance.
      
      The highest ancestor class this will return is the current class, even for plain
      jQuery objects, in order to allow Control methods ( like content() ) to be applied to
      the result.
    */

    cast: function(defaultClass) {
      var $e, elementClass, setClass, _i, _len, _ref, _ref1;
      defaultClass = defaultClass || this.constructor;
      setClass = void 0;
      _ref = this.segments();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        $e = _ref[_i];
        elementClass = (_ref1 = $e.controlClass()) != null ? _ref1 : defaultClass;
        if (setClass === void 0 || setClass.prototype instanceof elementClass) {
          setClass = elementClass;
        }
      }
      if (setClass == null) {
        setClass = defaultClass;
      }
      return setClass(this);
    },
    /*
      Execute a function once for each control in the array. The callback should
      look like
      
        $controls.eachControl( function( index, control ) {
          ...
        });
        
      This is similar to $.each(), but preserves type, so "this" and the control
      parameter passed to the callback are of the correct control class.
      
      NB: Unlike Control.segments(), this looks up the specific control class for each
      element being processed, rather than assuming the containing control's class
      is shared by all elements. If eachControl() is applied to a mixture of controls,
      the callback will be invoked with each control in turn using that specific
      control's class.
    */

    eachControl: function(fn) {
      var control, element, i, result, _i, _len;
      for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
        element = this[i];
        control = Control(element).cast();
        result = fn.call(control, i, control);
        if (result === false) {
          break;
        }
      }
      return this;
    },
    id: function(id) {
      return this.attr("id", id);
    },
    /*
      Experimental function like eq, but faster because it doesn't manipulate
      the selector stack.
    */

    nth: function(index) {
      return this.constructor(this[index]);
    },
    /*
      Invoke the indicated setter functions on the control to
      set control properties. E.g.,
      
         $c.properties( { foo: "Hello", bar: 123 } );
      
      is shorthand for $c.foo( "Hello" ).bar( 123 ).
    */

    properties: function(properties) {
      var propertyName, value;
      for (propertyName in properties) {
        if (this[propertyName] === void 0) {
          throw "Tried to set undefined property " + this.className + "." + propertyName + "().";
        }
        value = properties[propertyName];
        this[propertyName].call(this, value);
      }
      return this;
    },
    /*
      Get/set the given property on multiple elements at once. If called
      as a getter, an array of the property's current values is returned.
      If called as a setter, that property of each element will be set to
      the corresponding defined member of the values array. (Array values
      which are undefined will not be set.)
    */

    propertyVector: function(propertyName, values) {
      var $control, i, length, propertyFn, _i, _j, _len, _len1, _ref, _ref1, _results;
      propertyFn = this[propertyName];
      if (values === void 0) {
        _ref = this.segments();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          $control = _ref[_i];
          _results.push(propertyFn.call($control));
        }
        return _results;
      } else {
        length = this.length;
        _ref1 = this.segments();
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          $control = _ref1[i];
          if (i >= length) {
            break;
          }
          if (values[i] !== void 0) {
            propertyFn.call($control, values[i]);
          }
        }
        return this;
      }
    },
    /*
      Save or retrieve an element associated with the control using the given ref
      key. The getter form of this maps the array of control(s) to a collection of
      the corresponding element(s) that were previously saved under the given ref.
      The setter form has several effects:
      1. It saves a pointer to the indicated element in the control's data.
      2. It adds the ref as a CSS class to the target element.
      3. It generates an element reference function for the present control's class
         that permits future access to referenced elements.
      This function is generally for internal use, and is invoked during processing
      of Control JSON, or (in its getter form) from the generated element reference
      function mentioned in point #3.
    */

    referencedElement: function(ref, elements) {
      var $control, $result, i, _i, _len, _ref;
      if (elements === void 0) {
        elements = (function() {
          var _i, _len, _ref, _results;
          _ref = this.segments();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            $control = _ref[_i];
            if (($control.data(ref)) !== void 0) {
              _results.push($control.data(ref));
            }
          }
          return _results;
        }).call(this);
        $result = Control(elements).cast();
        $result.prevObject = this;
        return $result;
      } else {
        createElementReferenceFunction(this.constructor, ref);
        elements.addClass(ref);
        _ref = this.segments();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          $control = _ref[i];
          $control.data(ref, elements[i]);
        }
        return this;
      }
    },
    /*
      Return the controls in "this" as an array of subarrays, each of which holds
      a single control of the same class as the current control. E.g., if "this"
      contains a control object with
      
        [ control1, control2, control3, ... ]
        
      Then calling segments() returns
      
        [ [control1], [control2], [control3], ... ]
      
      This is useful in for loops and list comprehensions, and avoids callbacks.
      It is more sophisticated than simply looping over the control as a jQuery
      object, because that just loops over plain DOM elements, whereas segements()
      lets us loop over jQuery/Control objects that retain type information and,
      thus, direct access to class members.
    */

    segments: function() {
      var element, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        element = this[_i];
        _results.push(this.constructor(element));
      }
      return _results;
    },
    /*
      The tabindex of the control.
    */

    tabindex: function(tabindex) {
      if (tabindex === void 0) {
        return this.prop("tabindex");
      } else {
        return this.prop("tabindex", tabindex);
      }
    },
    /*
      Extra information about an element; e.g., to show as a ToolTip. This maps
      to the standard HTML title property on the control's top-level element.
    */

    title: function(title) {
      if (title === void 0) {
        return this.prop("title");
      } else {
        return this.prop("title", title);
      }
    }
  });

  /*
  Define a function on the given class that will retrieve elements with the given
  reference. Example: defining an element reference function on class Foo and
  reference "bar" will create Foo.prototype.$bar(), which returns the element(s)
  created with reference "bar".
  This has no effect if the class already has a function with the given name.
  */


  createElementReferenceFunction = function(classFn, ref) {
    var fnName;
    fnName = "$" + ref;
    if (!classFn.prototype[fnName]) {
      return classFn.prototype[fnName] = function(elements) {
        return this.referencedElement(ref, elements);
      };
    }
  };

}).call(this);
